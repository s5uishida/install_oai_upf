diff --git a/src/upf_app/SessionProgramManager.cpp b/src/upf_app/SessionProgramManager.cpp
index e1be3d205a7b947d3c21e8955e2a9073e3dd60c9..f6572cb2b08cb47b454e3c6706603c883029f4b5 100644
--- a/src/upf_app/SessionProgramManager.cpp
+++ b/src/upf_app/SessionProgramManager.cpp
@@ -443,8 +443,7 @@ void SessionProgramManager::updateARPTableForN6(
     pPFCP_Session_LookupProgram->getArpTableMap()->update(
         upfn6IP, map_table, BPF_ANY);
   } catch (const std::exception& ex) {
-    Logger::upf_app().error(
-        "Error: The ARP table was not updated for N6 Next HOP");
+    Logger::upf_app().warn("The ARP table was not updated for N6 Next HOP");
   }
 }
 
@@ -487,7 +486,7 @@ void SessionProgramManager::updateARPTableForN3(
   } catch (const std::exception& ex) {
     // Handle the exception here or log it for debugging
     // Note: It's better to handle exceptions rather than ignoring them.
-    Logger::upf_app().error(
+    Logger::upf_app().warn(
         "Error: The ARP table was not updated for N3 Next HOP");
   }
 }
diff --git a/src/upf_app/bpf/rules/pdr_and_far/pfcp_session_lookup_xdp_kernel.c b/src/upf_app/bpf/rules/pdr_and_far/pfcp_session_lookup_xdp_kernel.c
index 5f322ad37b37a6450f13d024d98cd990b2d6bafb..30d42cc6a5b42bc30eac13da0d2f37fe1f0ae6f3 100644
--- a/src/upf_app/bpf/rules/pdr_and_far/pfcp_session_lookup_xdp_kernel.c
+++ b/src/upf_app/bpf/rules/pdr_and_far/pfcp_session_lookup_xdp_kernel.c
@@ -65,10 +65,12 @@ struct vlan_hdr {
 static u32 upf_n3_ip = 0;
 static u32 upf_n6_ip = 0;
 
-static u8 next_hop_n3_mac_address[6] = {0};
+static u8 next_hop_n3_dst_mac_address[6] = {0};
+static u8 next_hop_n3_src_mac_address[6] = {0};
 // static u8 next_hop_n6_mac_address[6] = {0};
 
-static bool cached_n3 = false;
+static bool cached_n3     = false;
+static bool cached_n3_mac = false;
 // static bool cached_n6 = false;
 
 //#define MAX_PDRS_PER_SESSION 32
@@ -182,18 +184,6 @@ create_outer_header_gtpu_ipv4(struct xdp_md* ctx, pfcp_far_t_* p_far, u8 qfi) {
     cached_n3 = true;
   }
 
-  struct s_arp_mapping* map_entry = {0};
-  map_entry = bpf_map_lookup_elem(&m_arp_table, &upf_n3_ip);
-
-  if (!map_entry) {
-    bpf_debug("N3's Next Hop MAC address not found! Drop the packet");
-    return FAILURE;
-  }
-
-  memcpy(
-      next_hop_n3_mac_address, map_entry->mac_address,
-      sizeof(next_hop_n3_mac_address));
-
   /*
   |----------------------------------------------------------------|
   |----------------------- Update ETH header ----------------------|
@@ -246,6 +236,48 @@ create_outer_header_gtpu_ipv4(struct xdp_md* ctx, pfcp_far_t_* p_far, u8 qfi) {
       "outer IP header ( ip_saddr, ip_daddr ) : ( %pI4, %pI4 )", &iph->saddr,
       &iph->daddr);
 
+  /*
+  |----------------------------------------------------------------|
+  |----------------- Update Dest MAC Using FIB --------------------|
+  |----------------------------------------------------------------|
+  */
+  if (!cached_n3_mac) {
+    update_mac_address(ctx, ethh, iph, N3_INTERFACE);
+    // Copy to local src and dest MAC addresses for future use
+    memcpy(
+        next_hop_n3_dst_mac_address, ethh->h_dest,
+        sizeof(next_hop_n3_dst_mac_address));
+    memcpy(
+        next_hop_n3_src_mac_address, ethh->h_source,
+        sizeof(next_hop_n3_src_mac_address));
+
+    cached_n3_mac = true;
+  } else {
+    // Use the cached MAC addresses
+    memcpy(ethh->h_dest, next_hop_n3_dst_mac_address, sizeof(ethh->h_dest));
+    memcpy(ethh->h_source, next_hop_n3_src_mac_address, sizeof(ethh->h_source));
+  }
+  /*
+  |----------------------------------------------------------------|
+  |----------------- Update Dest MAC Using FIB --------------------|
+  |----------------------------------------------------------------|
+  */
+  if (!cached_n3_mac) {
+    update_mac_address(ctx, ethh, iph, N3_INTERFACE);
+    // Copy to local src and dest MAC addresses for future use
+    memcpy(
+        next_hop_n3_dst_mac_address, ethh->h_dest,
+        sizeof(next_hop_n3_dst_mac_address));
+    memcpy(
+        next_hop_n3_src_mac_address, ethh->h_source,
+        sizeof(next_hop_n3_src_mac_address));
+
+    cached_n3_mac = true;
+  } else {
+    // Use the cached MAC addresses
+    memcpy(ethh->h_dest, next_hop_n3_dst_mac_address, sizeof(ethh->h_dest));
+    memcpy(ethh->h_source, next_hop_n3_src_mac_address, sizeof(ethh->h_source));
+  }
   /*
   |----------------------------------------------------------------|
   |-------------------------- Add UDP header ----------------------|
@@ -269,8 +301,6 @@ create_outer_header_gtpu_ipv4(struct xdp_md* ctx, pfcp_far_t_* p_far, u8 qfi) {
   |-------------------------- Add GTP header ----------------------|
   |----------------------------------------------------------------|
   */
-  // Update destination mac address
-  memcpy(ethh->h_dest, next_hop_n3_mac_address, sizeof(ethh->h_dest));
 
   bpf_debug(
       "Destination MAC:%x:%x:%x:", ethh->h_dest[0], ethh->h_dest[1],
@@ -355,26 +385,39 @@ remove_outer_header_gtpu_ipv4(struct xdp_md* ctx, pfcp_far_t_* far) {
 
   e_reference_point n6_key = N6_INTERFACE;
 
-  // if (!cached_n6) {
   struct s_interface* map_element =
       bpf_map_lookup_elem(&m_upf_interfaces, &n6_key);
 
-  if (!map_element) {
-    bpf_debug("N6 interface is missing in UPF map. Drop the packet");
-    return FAILURE;
+  struct iphdr* iph = (void*) (new_ethh + 1);
+  if ((void*) (iph + 1) > data_end) {
+    return DROP;
   }
+  /*
+  |----------------------------------------------------------------|
+  |----------------- Update Dest MAC Using FIB --------------------|
+  |----------------------------------------------------------------|
+  */
+  if (!map_element) {
+    bpf_debug("N6 interface is missing in UPF map. Use FIB to update MAC");
 
-  upf_n6_ip = map_element->ipv4_address;
+    update_mac_address(ctx, new_ethh, iph, N3_INTERFACE);
+    // TODO:  Copy to local src and dest MAC addresses for future use
 
-  struct s_arp_mapping* map_entry = {0};
-  map_entry = bpf_map_lookup_elem(&m_arp_table, &upf_n6_ip);
+  } else {
+    upf_n6_ip = map_element->ipv4_address;
 
-  if (!map_entry) {
-    bpf_debug("N6's Next Hop MAC address not found. Drop the packet");
-    return FAILURE;
-  }
+    struct s_arp_mapping* map_entry = {0};
+    map_entry = bpf_map_lookup_elem(&m_arp_table, &upf_n6_ip);
 
-  memcpy(new_ethh->h_dest, map_entry->mac_address, sizeof(new_ethh->h_dest));
+    if (!map_entry) {
+      bpf_debug("N6's Next Hop MAC address not found. Use FIB to update MAC");
+      update_mac_address(ctx, new_ethh, iph, N3_INTERFACE);
+    } else {
+      bpf_debug("N6's Next Hop MAC address found in map_entry");
+      memcpy(
+          new_ethh->h_dest, map_entry->mac_address, sizeof(new_ethh->h_dest));
+    }
+  }
 
   bpf_debug(
       "Destination MAC  %x:%x:%x:", new_ethh->h_dest[0], new_ethh->h_dest[1],
diff --git a/src/upf_app/bpf/utils/utils.h b/src/upf_app/bpf/utils/utils.h
index 206c86171116d1ac4949952cdcbf7969e6036816..ec287f2445125cf1a4c812959ed9d58ea8ea0d7f 100644
--- a/src/upf_app/bpf/utils/utils.h
+++ b/src/upf_app/bpf/utils/utils.h
@@ -36,6 +36,23 @@
 #define ntohl(x) __constant_ntohl((x))
 #endif
 
+static void swap_src_dst_mac(void* data) {
+  bpf_debug("Swapping MAC address...\n");
+  unsigned short* p = data;
+  unsigned short dst[3];
+
+  dst[0] = p[0];
+  dst[1] = p[1];
+  dst[2] = p[2];
+  p[0]   = p[3];
+  p[1]   = p[4];
+  p[2]   = p[5];
+  p[3]   = dst[0];
+  p[4]   = dst[1];
+  p[5]   = dst[2];
+  bpf_debug("Swapping MAC address...DONE!\n");
+}
+
 /*****************************************************************************************************************/
 
 static __always_inline bool retrieve_upf_iface_from_map(
@@ -94,6 +111,9 @@ static __always_inline int update_mac_address(
   }
 
   fib_params.ifindex = ctx->ingress_ifindex;
+  bpf_debug(
+      "Calling FIB lookup ifindex:%d, src_ip:%pI4, dst_ip:%pI4",
+      fib_params.ifindex, &fib_params.ipv4_src, &fib_params.ipv4_dst);
 
   int rc = bpf_fib_lookup(ctx, &fib_params, sizeof(fib_params), 0);
   switch (rc) {
